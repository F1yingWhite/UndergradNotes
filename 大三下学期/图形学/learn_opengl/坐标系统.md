对我们来说比较重要的总共有5个不同的坐标系统：
- 局部空间(Local Space，或者称为物体空间(Object Space))
- 世界空间(World Space)
- 观察空间(View Space，或者称为视觉空间(Eye Space))
- 裁剪空间(Clip Space)
- 屏幕空间(Screen Space)

# 局部空间
局部空间就是对象刚开始所在的地方
# 世界空间
世界空间的坐标正如其名,是顶点相对于世界的坐标,将物体的坐标从局部变换到世界空间,这是由模型矩阵实现的.
# 观察空间
观察空间也就是摄像机,是用户视野的位置,这些组合通常在一个观察矩阵里面,将世界坐标变换到观察空间.
# 裁剪空间
任何在范围之外的点都应该被裁剪掉

我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：
Vclip=Mprojection⋅Mview⋅Mmodel⋅Vlocal



在开始进行3D绘图时，我们首先创建一个模型矩阵。这个模型矩阵包含了位移、缩放与旋转操作，它们会被应用到所有物体的顶点上，以**变换**它们到全局的世界空间。让我们变换一下我们的平面，将其绕着x轴旋转，使它看起来像放在地上一样。这个模型矩阵看起来是这样的：
model矩阵就是表示模型是如何变化的
```c++
glm::mat4 model; model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));
```
在下一个教程中我们将会详细讨论如何在场景中移动。就目前来说，观察矩阵是这样的：
```c++
glm::mat4 view;
// 注意，我们将矩阵向我们要进行移动场景的反方向移动。
view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
```
最后我们需要做的是定义一个投影矩阵。我们希望在场景中使用透视投影，所以像这样声明一个投影矩阵：
```c++
glm::mat4 projection;
projection = glm::perspective(glm::radians(45.0f), screenWidth / screenHeight, 0.1f, 100.0f);
```
