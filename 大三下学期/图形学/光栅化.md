光栅化就是把图形映射到像素上
![[Pasted image 20240414144818.png]]
如果像素在三角形内就把他画红
如何判断是不是里面？
![[Pasted image 20240414145100.png]]
使用叉乘，将三角形顺时针/逆时针连起来，总结而言就是，如果p在三角形内，那么三个叉乘的结果应该同时为正。而如果有任何一个结果为负，那么p在三角形外
![[Pasted image 20240414145332.png]]
但是这样会产生锯齿化问题，为了解决这个问题，我们需要反走样
# 反走样
先滤波/先采样![[Pasted image 20240414145630.png]]
提升屏幕像素（最直接）
## MSAA算法
将原来的像素全部切成2\*2大小，然后在判断哪些点在里面，最后根据像素点内被占满的百分比着不同深浅的颜色。
![[Pasted image 20240414145832.png]]![[Pasted image 20240414145837.png]]
# Z-buffering
画家算法：画家算法先画离自己远的，然后逐渐向近的地方画，防止被盖到。但是
![[Pasted image 20240414150032.png]]
这种呢？
![[Pasted image 20240414150111.png]]Z-Buffer算法就是记录下每个像素点最低的深度的颜色