# 内存管理
## 内存管理的功能有：
- 内存空间的分配与回收：由操作系统完成住寄存器空间的分配和管理，使程序员拜托存储分配的麻烦
- 地址转换：物理地址和逻辑地址的转换
- 内存空间的扩充：利用虚拟内存
- 存储保护：保证各个任务不相干

## 逻辑地址和物理地址
- 编译：将源程序编译为若干目标模块
- 链接：由连接程序将编译后形成的目标模块和所需的库函数连接在一起，形成一个完整的装入模块，由静态链接和动态链接，其中静态链接是在运行前就把所需的库函数链接为完整的可执行程序不再拆开，而装入时链接实在转入内存时变装入边链接，而运行时链接是在运行的时候需要才链接
- 装入：将程序装入内存
每个目标模块都由0号单元开始，这称为逻辑地址。用户和程序只需要知道逻辑地址。。
物理地址是内存中的物理单元的集合，他是最终的地址，进程在执行和访问数据的时候都要从物理地址从主存存取。需要进行地址重定位。
- 内存保护：由一个上下限寄存器，存放用户作业在主存的上下限地址，每当cpu需要访问地址的时候就先比对，防止越界
- 动态重定位是指在作业运行过程中执行到一条访存指令时，再把逻辑地址转换为主存中的物
## 覆盖和交换
早期的多道程序下扩充内存的方式有俩
- 覆盖：早期的主存容量小，程序运行的时候只载入需要的部分按需载入，其他部分放在外存，需要的时候再载入覆盖区
- 交换：把处于等待状态的程序从内存移出去，再把准备好的放到内存中，这就是换入换出
## 连续分配管理方式
- 单一连续分配：系统区在低地址部分，用户区是为用户提供的，无需保护，因为内存中只有一个程序
- 固定分区分配：将用户空间分为若干固定大小的区域，每个分区只装入1个作业，当有空闲分区的时候就从后备队列选择合适大小的作业装入分区，有分区大小确定和不确定两种方式，但是程序可能太大放不进去，小了有存在<font color="#2DC26B">内部碎片</font>，指的是分区内存在小的碎片没占用，但是别人又用不了![[Pasted image 20240511212830.png]]
- 动态分区分配：不事先划分分区，而是在装入的过程中根据进程的大小建立分区，并使分区的大小刚好适合进程的需要。但是会产生很多的碎片，小的内存被称为<font color="#2DC26B">外碎片</font>，指的就是太小了没办法用
动态分区分配的算法有：
- 首次适应：顺序查找，找到第一个能够满足要求的空闲分区
- 最佳适应：找到刚好能符合自己的分区
- 最坏适应：找到最大的空闲分区
- 临近算法：找到上一次之后的位置的后面第一个符合的
## 非连续内存管理
### 基本分页存储管理方式
固定分区会产生内碎片，动态分区会产生外碎片，利用率都较低，我们希望尽量避免碎片产生，这就产生了分页的思想，我们把主存空间划分为大小相等的固定块，块相对较小，作为主存的基本单位，每个进程也按照块来划分。
不产生外部碎片，只会产生一个页内碎片
(1)分页存储的几个概念：
进程的块称为页，内存中的块称为页框/帧，外存也同单位大小分为块
地址结构为：页号-页内偏移
页表：找到每个进程的物理地址的物理块。系统为每个进程创建一个页表，记录页面在内存中的对应的物理块号，页号-物理地址块号![[Pasted image 20240511215628.png]]
用页表来映射，每次存取需要访问两次内存，相当于速度慢了一半，这时候我们就需要TLB快表（具有并行查找能力的高速缓冲存储器相联存储区）来加速
- 当给出逻辑地址，有硬件进行地址转换，将页号放入告诉寄存器，并且把页号与快表的页号进行对比
- 如果找到匹配页号，那么直接取出来，与偏移量拼接。
- 如果找不到，那就访问主存的页表，找出对应项后存入快表
逻辑地址A到物理地址E的过程如下：
- 计算页号（A/L）和页内偏移(W=A%L)
- 比较页号和页表长度防止越界
- 页表项地址：页表地址+页号\*页表项长度=>页表内容b也就是物理块号
为了减少页表的使用量，我们给出了二级页表，实际上就是在原来的结构上再加了一层页表
### 基本分段存储管理方式
能够体现程序的逻辑结构
段间离散，段内连续，将任务划分为不同的断，比如主程序，函数和数据部分
段号-段内偏移
断表：段号-段长-物理地址
### 段页式管理方式
两种方式结合，能提高内存利用率和段的共享。
逻辑地址分为三块：段号-页号-页内偏移
每个进程一个段表，每个段表一个页表。首先通过段表找到页表位置，然后通过页表找页帧号，最后形成物理地址

# 虚拟内存管理
## 虚拟寄存器的定义和特征
这种寄存器实际上不存在,给用户的感觉就是好像有一个比实际存储大得多的存储器.虚拟寄存器的大小由计算机的抵制结构决定.
虚拟内存技术允许把一个作业分多次调入内存,采用连续分配的时候,会是相当一部分内存空间在空闲状态,造成资源的浪费.
## 页面置换算法
- 最佳置换OPT算法:置换出最长时间不使用的页面,当然,我们无法预知,所以这是无法实现的
- 先进先出FIFO:最早淘汰最先进如内存的页面,但是存在物理块数目增加故障树数目而减少的情况,这种情况称为Belady异常
- LRU算法(最近最久未使用):跟FIFO的区别就是置换的是最长没有使用的
- 时钟Clock置换算法:![[Pasted image 20240512110020.png]]
只有在缺页的时候才会移动指针![[Pasted image 20240512111132.png]]
### 抖动
刚刚换出的页面马上又要换入主存，这种频繁额页面调度行为就叫抖动。
### 地址翻译
