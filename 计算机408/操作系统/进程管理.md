# 什么是进程
在多道程序环境下，允许多个程序并发，此时他们会失去封闭性，具有间断性及不可再现特性，为此引入了进程的概念，实现<font color="#2DC26B">并发和共享</font>。PCB就是进程控制块，系统利用PCB来描述进程的基本状态，是进程的唯一表述。
进程的状态有：![[Pasted image 20240510110553.png]]
运行态：正在运行
就绪态：获得了所有的资源等待调度
阻塞态：进程正在等待某一事件而暂停运行。
创建态：正在被创建
结束态：进程结束

## 进程通信
### 共享存储
![[Pasted image 20240510111042.png]]
放一块共享空间，通过对这块空间进行读写的方式实现进程的切换，就是一个人往里面放东西，一个人拿东西
### 消息传递
- 直接通信方式：进程直接把消息发给接受进程，并且将它挂在接收进程的笑嘻缓冲队列上。接受进程从消息缓冲队列中取得消息
- 简介通信：消息发送到某个中间实体，然后接收进程冲中间实体拿信息
- 管道通信：将信息写入文件，叫做pipe文件，一个写入一个读出
![[Pasted image 20240510152724.png]]
长期调度：选择任务并且将它放入准备队列
中期调度：选择任务被切换出去
短期调度：决定哪个任务执行
## 线程
引入进程的目的是让多个程序并发，提高资源利用率与系统吞吐量；引入进程的目的是减少程序在并发执行时所付出的时空开销，提升系统的并发能力。因为线程切换的时候进程没有切换，而切换线程的开销更小。
存在用户级线程和内核级线程，
![[Pasted image 20240510112013.png]]
## 进程调度
分为抢占和非抢占
CPU利用率：保证系统尽可能忙
系统吞吐量：单位时间内的CPU完成作业量
周转周期：从作业提交到作业完成花费的时间
等待时间：等待时间指处理机没有工作的时间
响应时间：用户提交任务到首次发生请求的时间
### FCFS
先来先服务，效率低，对长作业有利，短作业不利，利于cpu密集型
### SJF
最短时间先来，平均等待时间最少，周转周期最少
### SRJF
剩下时间最短的先执行，SRJF，是可被抢断的Preemptive
### 优先级调度算法
优先级高的先来，不抢断，可以使用Aging解决低优先级任务无法执行的缺点
### 时间片轮询
系统将所有的就绪进程按照到达时间的先后次序排成一个队列，同一时刻只能运行一个时间片
### 多级反馈队列调度算法
![[Pasted image 20240510153015.png]]
第1级先运行，然后逐级向下执行
# 并发锁问题
- 死锁：两个任务互相等待
- 饥饿问题：有任务永远执行不到
必须要有空让进（deadlock-free）和有限等待（starvation-free）
必须要硬件支持：必须支持原子操作
## 信号量
使用信号量P和V指使是否停止和运行。可以使用信号量控制运行的先后![[Pasted image 20240510154335.png]]
```c++
semaphore Empyt_Water=10,Full_Water=0,jing=1,tong=3,gang=1
V(Empyt_Water)
V(tong)
V(jing)
p(jing)
V(gang)
P(gang)
P(Full_Water)

V(Full_Water)
v(tong)
v(gang)
p(gang)
p(tong)
p(Empty_water)
```
# 死锁
## 必要条件
- 持有并等待
- 互斥
- 不抢占
- 循环等待
## 处理方式
- 死锁预防：打破一个或几个必要条件
- 避免死锁：在资源调配中防止进入不安全状态
- 死锁检测：不采取任何措施，但是能够及时的检测死锁的发生
## 死锁避免
系统安全状态：在申请前计算此次分配的安全，所谓安全状态，就是指系统能通过某种顺序让每个进程都可以分配![[Pasted image 20240510161224.png]]
银行家算法同理
## 死锁检测
资源分配图：![[Pasted image 20240510161821.png]]
