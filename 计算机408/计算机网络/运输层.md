运输层位不同主机上的进程提供逻辑通信功能，将应用层报文转化为运输层分组（报文段）。将主机间交付扩展到多个进程就叫做多路复用和多路分解。
将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用。
# UDP无连接运输
用户数据报协议（UDP，User Datagram Protocol）
udp几乎没有对ip增加别的东西，一共占8字节
![[Pasted image 20240505213301.png]]
UDP检验和：检查是否发生了比特位的改变。发送报文段所有16位比特和进行反码运算；
![[Pasted image 20240505223258.png]]
加法溢出后把1放到最后，然后再把所有的0都换成1，所以校验和就是101101010011110

# TCP
## 可靠数据传输原理
因为网络层在传输过程中会发生一定的改变，所以需要可靠数据传输原理。
我们的有限状态机分为4个版本
### rdt1.0完全可靠信道
发送就完了
### 具有比特差错信道的可靠传输 rdt2.0
使用肯定确认和否定确认，因此需要自动重传，收到报错自动重传，发送后停止等待返回的ACK/NAK，这个版本叫做停等协议。
但是我们没有考虑到ACK和NAK损失，当我们收到听不懂的时候直接重发一遍即可，这个分组就叫做冗余分组。接收方检查在请求头的存放的序号决定是否重传。当然我们这样就可以不需要NAK了，只需要重传ACK
### 具有比特差错和丢包的传输rdt3.0
底层信道还会丢包，因此我们还需要计时器来倒计时，如果到时间了还没有收到那就发一次请求告诉他。
当然了，这样的停等协议效率上太慢了！于是我们将他改造为流水线协议。根据如何处理错误状态，有两种方法，GoBackN和选择重传
### GoBackN
gobackn也叫滑动窗口协议，采用累计确认的方式，必须按顺序确认
![[Pasted image 20240505231019.png]]![[Pasted image 20240505231148.png]]、
### 选择重传SR
![[Pasted image 20240505231311.png]]
## TCP
tcp是点对点的，建立链接需要三次握手四次挥手![[Pasted image 20240505231846.png]]
MSS最大报文段长度：单次发送的报文段最长是多少,使用累计确认的方式
.<font color="#2DC26B">当tcp收到失序的报文段之后其实没有规定到底该怎么办,可以丢弃也可以缓存</font>.
ACK可以看做下一个想要什么
![[Pasted image 20240506085635.png]]
往返时间估计:$EstimateRTT = (1-a)EstimateRTT+a*SampleRTT$.一般a取0.125
RTT偏差$DevRTT=(1-a)*devrtt+a*|sampleRTT-EstimateRTT|$.一般a取0.25
设置超时时间为$TimeoutInterval=EstimateRTT+4*DevRTT$
- 超时间隔加倍:每丢失一次TCP的重传时间就+一倍
- 快速重传:收到3个冗余ACK立刻重传
- TCP的接受机制为可以缓存但是只发送最低的ACK,相当于GBN+SR合体
### 流量控制
TCP为他的服务提供了流量控制服务,让发送方维护一个接收窗口,用于指示接收方还有多少缓存空间,不允许LastByteRevd-LastByteRead<=RcvBuffer![[Pasted image 20240506091115.png]]
### TCP连接管理
三次握手:
- 客户端向服务器发送一个SYN比特位被设为1的报文,叫做SYN报文段,并且客户选择一个随机的初始序号
- 客户端收到后分配TCP缓存,返回一个SYNACK报文段,带有随机初识序号
- 再次发送一个SYN被置为0的报文![[Pasted image 20240506091936.png]]
四次挥手

![[Pasted image 20240506092025.png]]
### 拥塞控制
运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥塞窗口 （congestion window).拥塞窗口表示为cwnd,它对一个TCP发送方能向网络中发送流量的速率进行了限制。接收方缓存里面的内容应该小于min{cwnd,rwnd}
- 慢启动:当TCP开始的时候,cwnd是一个MSS较小的值,发送速率为MSS/RTT,每次加一个MSS,每次翻倍,其实不慢
- 当一个丢包出现的时候,cwnd变为1并重新慢启动,到达cwnd/2的时候,每次长一个.当遇到3个冗余ACK,快速重传并且进如快速恢复
- 拥塞避免:就是超过ssthresh后,速度变为每次加一个
- 快速回复:快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 `RTO` 超时那么强烈。
	- 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
	- 重传丢失的数据包；
	- 如果再收到重复的 ACK，那么 cwnd 增加 1；
	- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；
![[Pasted image 20240506093128.png]]

